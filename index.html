<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tiny Flashcards</title>
  <style>
    :root { --bg:#000; --fg:#fff; --muted:#9a9a9a; }
    *{ box-sizing:border-box }
    html,body{ height:100%; margin:0 }

    /* Fixed background image via ::before pseudo-element */
    body::before{
      content:"";
      position: fixed;
      inset: 0;
      background: url('bg.jpg') center/cover no-repeat;
      z-index: -2;
    }

    body{
      font-family:"Times New Roman", Georgia, serif;
      color:var(--fg);
      background: var(--bg);
      display:block;
      min-height:100vh;
    }

    .app{ width:min(860px,94%); margin:14vh auto 24vh; display:grid; gap:28px }

.card{
  border: 3px solid var(--fg);
  border-radius: 40px;
  /* make the actual card transparent… */
  background: transparent;
  /* …and draw the black panel inside with ::before */
  position: relative;
  padding: 64px 44px 36px;
  text-align: center;
}

/* inner black panel, inset from the white border */
.card::before{
  content: "";
  position: absolute;
  inset: 2px;                        /* tweak this to change how much black you see */
  background: rgba(0,0,0,0.8);
  border-radius: calc(40px - 12px);   /* keep corners nicely rounded */
  z-index: 0;
}

/* ensure your content sits above the inner panel */
.card > * { position: relative; z-index: 1; }


    #stage{ min-height:clamp(220px,40vh,420px); display:grid; place-items:center; gap:14px }

    .prompt{ font-size:clamp(34px,3.8vw,50px); letter-spacing:.3px; margin:0 }
    .translation{ display:block; min-height:2.6em; font-size:clamp(26px,2.9vw,38px); color:var(--muted); transition:opacity .15s ease }
    .translation.hidden{ visibility:hidden; opacity:0 }
    .translation.visible{ visibility:visible; opacity:.95 }

    .row{ display:flex; justify-content:center; gap:18px; margin-top:28px }
    button{ font:18px/1.2 inherit; color:var(--fg); background:transparent; border:2px solid var(--fg); border-radius:50px; padding:12px 30px; cursor:pointer; transition:all .15s ease }
    button:hover{ background:var(--fg); color:var(--bg) }
    button:disabled{ opacity:.35; cursor:not-allowed }

    .footer{ text-align:center; font-size:14px; letter-spacing:.6px; background: rgba(0,0,0,0.6); padding: 16px 24px; border-radius: 12px; display: inline-block; }
    .footer-title{ font-family: 'Arial', 'Helvetica', sans-serif; font-weight: bold; color: #39ff14; font-size: 13px; letter-spacing: 1.2px; text-transform: uppercase; }
    .shuffle-btn{ display:flex; justify-content:center; margin-bottom:16px; flex-direction: column; align-items: center; gap: 12px; }
    .card-counter{ font-family: 'Arial', 'Helvetica', sans-serif; font-weight: bold; color: #39ff14; font-size: 14px; background: rgba(0,0,0,0.6); padding: 8px 20px; border-radius: 12px; }
    .toplink{ position: fixed; top: 12px; right: 12px; color: var(--fg); text-decoration: none; border: 2px solid var(--fg); border-radius: 999px; padding: 6px 16px; font-size: 14px; background: rgba(0,0,0,0.6); transition: all 0.15s ease; z-index: 100; }
    .toplink:hover{ background: var(--fg); color: var(--bg); }
  </style>
</head>
<body>
  <a class="toplink" href="decks.html">Fasciculī</a>
  <main class="app" id="app">
    <div class="shuffle-btn">
      <button id="shuffleBtn">Shuffle</button>
      <div class="card-counter" id="cardCounter">1/5</div>
    </div>
    <div class="card">
      <div id="stage">
        <div class="prompt" id="lineText" aria-live="polite"></div>
        <div class="translation hidden" id="lineTrans" style="margin-top:16px"></div>
      </div>
      <div class="row" id="controlsBottom">
        <button id="prevBtn">⟵ Prev</button>
        <button id="nextBtn">Next ⟶</button>
      </div>
    </div>
    <div style="text-align:center;">
      <div class="footer">
        <span class="footer-title">Mr. Heise's Latin Flashcards</span><br>
        <span style="opacity:0.7; font-size:12px; margin-top:8px; display:inline-block;">
          Keyboard: Space or → for Next · ← for Previous
        </span>
      </div>
    </div>
  </main>

  <script>
    let deck = [
      { q: "Ī ad popīnam pedibus.", a: "Go to the restaurant on foot." },
      { q: "Ī ad librāriam bīrotā.", a: "Go to the bookstore by bike." },
      { q: "Dic 'sōl est.'", a: "Say 'it is the sun.'" },
      { q: "Quot gladīī sunt?", a: "How many swords are there?" },
      { q: "Unus gladius est.", a: "There is one sword." }
    ];

    const DECK_URLS = Array.from({length: 20}, (_, i) => `decks/b${i+1}.txt`);

    const el = (id) => document.getElementById(id);
    const lineText = el('lineText');
    const lineTrans = el('lineTrans');
    const nextBtn = el('nextBtn');
    const prevBtn = el('prevBtn');
    const shuffleBtn = el('shuffleBtn');
    const cardCounter = el('cardCounter');

    let order = deck.map((_, i) => i);
    let idx = 0;
    let showingA = false;

    function shuffleArray(arr){
      for(let i=arr.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [arr[i],arr[j]] = [arr[j],arr[i]];
      }
      return arr;
    }

    function shuffleDeck(){
      order = shuffleArray(deck.map((_, i) => i));
      idx = 0;
      showingA = false;
      render();
    }

    function rebuildOrder(){
      order = deck.map((_, i) => i);
      idx = 0;
      showingA = false;
      render();
    }

    function render(){
      const current = deck[ order[idx] ];
      if(!current){
        lineText.textContent = "(No cards)";
        lineTrans.classList.add('hidden');
        nextBtn.disabled = true; prevBtn.disabled = true;
        cardCounter.textContent = "0/0";
        return;
      }
      nextBtn.disabled = false; prevBtn.disabled = false;
      lineText.textContent = current.q;
      lineTrans.textContent = current.a;
      lineTrans.classList.toggle('visible', showingA);
      lineTrans.classList.toggle('hidden', !showingA);
      cardCounter.textContent = `${idx + 1}/${deck.length}`;
    }

    function next(){
      if(deck.length===0) return;
      if(!showingA){
        showingA = true;
      } else {
        if(idx < order.length - 1){
          idx++;
          showingA = false;
        } else {
          idx = 0;
          showingA = false;
        }
      }
      render();
    }

    function prev(){
      if(deck.length===0) return;
      if(showingA){
        showingA = false;
      } else if(idx>0){
        idx--; showingA = false;
      }
      render();
    }

    nextBtn.addEventListener('click', next);
    prevBtn.addEventListener('click', prev);
    shuffleBtn.addEventListener('click', shuffleDeck);

    window.addEventListener('keydown', (e) => {
      if(e.code === 'Space' || e.key === 'ArrowRight'){ e.preventDefault(); next(); }
      if(e.key === 'ArrowLeft'){ e.preventDefault(); prev(); }
    });

    function parseLinesToDeck(text){
      const lines = text.split(/\n+/).map(s=>s.trim()).filter(Boolean);
      const out = [];
      for(const line of lines){
        const parts = line.split(/\s*(?:=|—|-|:)\s*/);
        if(parts.length>=2){
          const q = parts[0].trim();
          const a = parts.slice(1).join(' - ').trim();
          if(q && a) out.push({q,a});
        }
      }
      return out;
    }

    async function loadRandomDeckFromUrls(){
      // Check if a specific deck is requested via URL parameter
      const urlParams = new URLSearchParams(window.location.search);
      const deckNum = urlParams.get('deck');
      
      if (deckNum) {
        // Load specific deck
        const deckUrl = `decks/b${deckNum}.txt`;
        try{
          const res = await fetch(deckUrl, {cache:'no-store'});
          if(!res.ok) throw new Error(res.status+' '+res.statusText);
          const text = await res.text();
          const parsed = parseLinesToDeck(text);
          if(parsed.length){ deck = parsed; return true; }
        }catch(e){ console.warn('Deck load failed:', e); }
        return false;
      }
      
      // Otherwise load random deck
      if(!Array.isArray(DECK_URLS) || !DECK_URLS.length) return false;
      const pick = DECK_URLS[Math.floor(Math.random()*DECK_URLS.length)];
      try{
        const res = await fetch(pick, {cache:'no-store'});
        if(!res.ok) throw new Error(res.status+' '+res.statusText);
        const text = await res.text();
        const parsed = parseLinesToDeck(text);
        if(parsed.length){ deck = parsed; return true; }
      }catch(e){ console.warn('Random deck load failed:', e); }
      return false;
    }

    loadRandomDeckFromUrls().then(()=>{ rebuildOrder(); });
  </script>
</body>
</html>
