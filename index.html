<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tiny Flashcards</title>
  <style>
    :root{--bg:#0f172a;--card:#111827;--ink:#e5e7eb;--muted:#9ca3af;--accent:#22c55e;--accent2:#38bdf8}
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font:16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";color:var(--ink);background:linear-gradient(180deg,#0b1226,#0f172a)}
    .wrap{min-height:100%;display:grid;place-items:center;padding:24px}
    .app{width:min(900px,100%);display:grid;gap:16px}
    .card{background:var(--card);border:1px solid #1f2937;border-radius:18px;padding:24px 24px 18px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .prompt{font-size:clamp(20px,2.6vw,28px);letter-spacing:.2px}
    .translation{opacity:.9}
    .muted{color:var(--muted)}
    .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    .row.space{justify-content:space-between}
    button{border:0;border-radius:14px;padding:12px 16px;font-weight:600;cursor:pointer;transition:transform .06s ease,opacity .2s ease,box-shadow .2s ease}
    button:active{transform:translateY(1px)}
    .btn{background:#0ea5e9;color:white}
    .btn.secondary{background:#334155}
    .btn.success{background:#22c55e}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .chip{display:inline-flex;gap:8px;align-items:center;padding:8px 12px;border-radius:999px;background:#0b1226;border:1px solid #1f2937}
    input[type="checkbox"]{inline-size:1.15rem;block-size:1.15rem}
    progress{width:180px;height:10px;border-radius:99px;overflow:hidden;background:#0b1226;border:1px solid #1f2937}
    progress::-webkit-progress-bar{background:#0b1226}
    progress::-webkit-progress-value{background:linear-gradient(90deg,var(--accent),var(--accent2))}
    progress::-moz-progress-bar{background:linear-gradient(90deg,var(--accent),var(--accent2))}
    .small{font-size:12px}
    .footer{opacity:.7;text-align:center;margin-top:8px}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;background:#0b1226;border:1px solid #1f2937;border-bottom-width:2px;padding:2px 6px;border-radius:6px}
    details{background:#0b1226;border:1px dashed #374151;border-radius:14px;padding:8px 12px}
    textarea{width:100%;min-height:140px;background:#0b1226;border:1px solid #1f2937;border-radius:12px;color:var(--ink);padding:12px;font:14px/1.4 ui-monospace,SFMono-Regular,Menlo,monospace}
    .import-grid{display:grid;gap:10px}
    @media (max-width:520px){
      .row.stack{flex-direction:column;align-items:stretch}
      progress{width:100%}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <main class="app" id="app">

      <div class="card">
        <div class="row space">
          <div class="row" role="group" aria-label="Controls">
            <button class="btn secondary" id="prevBtn" title="Previous (‚Üê)">‚üµ Prev</button>
            <button class="btn" id="nextBtn" title="Next / Reveal (Space or ‚Üí)">Next ‚ü∂</button>
          </div>
          <div class="row">
            <label class="chip"><input type="checkbox" id="shuffleChk"> <span>Shuffle</span></label>
            <label class="chip"><input type="checkbox" id="loopChk" checked> <span>Loop</span></label>
          </div>
        </div>

        <div id="stage" style="margin:14px 0 10px">
          <div class="prompt" id="lineText" aria-live="polite"></div>
          <div class="translation muted" id="lineTrans" style="display:none;margin-top:8px"></div>
        </div>

        <div class="row space stack" style="margin-top:6px">
          <div class="row" style="gap:14px">
            <span class="chip" id="posChip">Card <span id="pos">1</span>/<span id="total">1</span></span>
            <progress id="prog" value="0" max="100" aria-label="Progress"></progress>
          </div>
          <div class="small muted">Tip: press <span class="kbd">Space</span> or <span class="kbd">‚Üí</span> for Next, <span class="kbd">‚Üê</span> for Prev.</div>
        </div>
      </div>

      <details>
        <summary>üì• Quick import (paste list ‚Üí build cards)</summary>
        <div class="import-grid">
          <p class="muted small">Paste lines as <code>prompt = translation</code> (or use <code>‚Äî</code>, <code>-</code>, <code>:</code>). One pair per line.</p>
          <textarea id="bulkInput" placeholder="Salvƒì! = Hello!
N≈çlƒ´ timƒìre. = Do not be afraid.
Quid agis? ‚Äî How are you?"></textarea>
          <div class="row">
            <button class="btn success" id="importBtn">Import</button>
            <button class="btn secondary" id="exportBtn" title="Copy current deck as text">Export</button>
          </div>

          <div class="row" style="margin-top:8px">
            <button class="btn secondary" id="loadFileBtn" title="Load a local file of cards">Load file‚Ä¶</button>
            <button class="btn secondary" id="loadUrlBtn" title="Fetch cards from a URL">Load from URL‚Ä¶</button>
            <input type="file" id="fileInput" accept=".json,.csv,.txt" style="display:none" />
          </div>
          <p class="small muted">Accepted formats: <b>JSON</b> (array of {q,a}), <b>CSV</b> (columns <code>q,a</code>), or plain text lines like <code>prompt = translation</code>.</p>
        </div>
      </details>

      <div class="footer small">Tiny Flashcards ¬∑ one HTML file ¬∑ no libraries</div>
    </main>
  </div>

  <script>
    // ---------------------------
    // 1) Your data lives here üëá
    // Edit this array, or use the importer below. Each item is { q: "prompt", a: "translation" }
    let deck = [
      { q: "ƒ™ ad popƒ´nam pedibus.", a: "Go to the restaurant on foot." },
      { q: "ƒ™ ad librƒÅriam bƒ´rotƒÅ.", a: "Go to the bookstore by bike." },
      { q: "Dic 's≈çl est.'", a: "Say 'it is the sun.'" },
      { q: "Quot gladƒ´ƒ´ sunt?", a: "How many swords are there?" },
      { q: "Unus gladius est.", a: "There is one sword." },
    ];

    // ---------------------------
    // 2) App state
    const el = (id) => document.getElementById(id);
    const lineText = el('lineText');
    const lineTrans = el('lineTrans');
    const nextBtn = el('nextBtn');
    const prevBtn = el('prevBtn');
    const shuffleChk = el('shuffleChk');
    const loopChk = el('loopChk');
    const pos = el('pos');
    const total = el('total');
    const prog = el('prog');

    let order = deck.map((_, i) => i);
    let idx = 0;             // which card in the order
    let showingA = false;    // false = show prompt; true = show translation

    // Restore toggles from localStorage
    shuffleChk.checked = localStorage.getItem('tinyfc_shuffle') === '1';
    loopChk.checked    = localStorage.getItem('tinyfc_loop')    !== '0';

    function shuffleArray(arr){
      for(let i=arr.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [arr[i],arr[j]] = [arr[j],arr[i]];
      }
      return arr;
    }

    function rebuildOrder(){
      order = deck.map((_, i) => i);
      if(shuffleChk.checked) shuffleArray(order);
      idx = 0;
      showingA = false;
      render();
    }

    function render(){
      total.textContent = deck.length;
      const current = deck[ order[idx] ];
      if(!current){
        lineText.textContent = "(No cards)";
        lineTrans.style.display = 'none';
        nextBtn.disabled = true; prevBtn.disabled = true;
        pos.textContent = '0'; prog.value = 0; return;
      }
      nextBtn.disabled = false; prevBtn.disabled = false;

      lineText.textContent = current.q;
      lineTrans.textContent = current.a;
      lineTrans.style.display = showingA ? 'block' : 'none';
      pos.textContent = String(idx+1);
      const pct = Math.round(((idx) / Math.max(deck.length,1)) * 100);
      prog.value = pct;
      document.title = (showingA?"A: ":"Q: ") + current.q.replace(/<[^>]*>/g,'');
    }

    function next(){
      if(deck.length===0) return;
      if(!showingA){
        // reveal translation
        showingA = true;
      } else {
        // advance to next card
        if(idx < order.length - 1){
          idx++;
          showingA = false;
        } else if(loopChk.checked){
          rebuildOrder();
          return; // render was called in rebuildOrder
        } else {
          showingA = true; // stay on last answer
          nextBtn.disabled = true; // end
        }
      }
      render();
    }

    function prev(){
      if(deck.length===0) return;
      if(showingA){
        // go back to prompt of same card
        showingA = false;
      } else if(idx>0){
        idx--; showingA = false;
      }
      render();
    }

    // Wire UI
    nextBtn.addEventListener('click', next);
    prevBtn.addEventListener('click', prev);

    shuffleChk.addEventListener('change', () => {
      localStorage.setItem('tinyfc_shuffle', shuffleChk.checked ? '1':'0');
      rebuildOrder();
    });
    loopChk.addEventListener('change', () => {
      localStorage.setItem('tinyfc_loop', loopChk.checked ? '1':'0');
    });

    // Keyboard controls
    window.addEventListener('keydown', (e) => {
      if(['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return;
      if(e.code === 'Space' || e.key === 'ArrowRight'){ e.preventDefault(); next(); }
      if(e.key === 'ArrowLeft'){ e.preventDefault(); prev(); }
    });

    // Import / Export helpers (paste box)
    const bulkInput = el('bulkInput');
    el('importBtn').addEventListener('click', () => {
      const parsed = parseLinesToDeck(bulkInput.value);
      if(parsed.length){ deck = parsed; rebuildOrder(); }
      else alert('Could not find any ‚Äúprompt = translation‚Äù lines to import.');
    });

    el('exportBtn').addEventListener('click', async () => {
      const text = deck.map(d=>`${d.q} = ${d.a}`).join('\n');
      try{
        await navigator.clipboard.writeText(text);
        alert('Deck copied to clipboard!');
      }catch{
        // fallback download
        const blob = new Blob([text], {type:'text/plain'});
        const a=document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'flashcards.txt';
        document.body.appendChild(a); a.click(); a.remove();
      }
    });

    // -------- Parsers for external sources --------
    function parseLinesToDeck(text){
      const lines = text.split(/\n+/).map(s=>s.trim()).filter(Boolean);
      const out = [];
      for(const line of lines){
        const parts = line.split(/\s*(?:=|‚Äî|-|:)\s*/);
        if(parts.length>=2){
          const q = parts[0].trim();
          const a = parts.slice(1).join(' - ').trim();
          if(q && a) out.push({q,a});
        }
      }
      return out;
    }
    function parseCSVToDeck(text){
      const rows = text.split(/\r?\n/).filter(Boolean);
      if(!rows.length) return [];
      const splitCSV = (line)=> line
        .split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/)
        .map(s=>s.replace(/^"|"$/g,'').trim());
      const header = splitCSV(rows[0]).map(h=>h.toLowerCase());
      const qi = header.indexOf('q'); const ai = header.indexOf('a');
      if(qi===-1 || ai===-1) return [];
      const out = [];
      for(let i=1;i<rows.length;i++){
        const cols = splitCSV(rows[i]);
        const q = cols[qi]; const a = cols[ai];
        if(q && a) out.push({q,a});
      }
      return out;
    }
    function parseJSONToDeck(text){
      try{
        const data = JSON.parse(text);
        if(Array.isArray(data)) return data
          .map(x=>({q: x.q ?? x.front ?? x.prompt, a: x.a ?? x.back ?? x.answer}))
          .filter(x=>x.q && x.a);
      }catch{}
      return [];
    }
    function loadDeckFromText(text, hint){
      let parsed = [];
      if(hint==='json') parsed = parseJSONToDeck(text);
      if(!parsed.length && hint==='csv') parsed = parseCSVToDeck(text);
      if(!parsed.length) parsed = parseJSONToDeck(text);
      if(!parsed.length) parsed = parseCSVToDeck(text);
      if(!parsed.length) parsed = parseLinesToDeck(text);
      if(parsed.length){ deck = parsed; rebuildOrder(); }
      else alert('Could not parse any cards from the provided ' + (hint||'data') + '.');
    }

    // -------- File/URL loading --------
    const fileInput = el('fileInput');
    const loadFileBtn = el('loadFileBtn');
    const loadUrlBtn = el('loadUrlBtn');

    if(loadFileBtn){
      loadFileBtn.addEventListener('click', () => fileInput && fileInput.click());
    }
    if(fileInput){
      fileInput.addEventListener('change', () => {
        const f = fileInput.files[0]; if(!f) return;
        const reader = new FileReader();
        reader.onload = () => {
          const ext = (f.name.split('.').pop()||'').toLowerCase();
          const hint = ['json','csv'].includes(ext) ? ext : undefined;
          loadDeckFromText(String(reader.result||''), hint);
        };
        reader.readAsText(f);
        fileInput.value = '';
      });
    }

    if(loadUrlBtn){
      loadUrlBtn.addEventListener('click', async () => {
        const url = prompt('Enter the URL of your deck file (JSON, CSV, or text):');
        if(!url) return;
        try{
          const res = await fetch(url, {cache:'no-store'});
          if(!res.ok) throw new Error(res.status+' '+res.statusText);
          const text = await res.text();
          const m = url.toLowerCase().match(/\.([a-z0-9]+)(?:\?|#|$)/);
          const hint = m ? m[1] : undefined;
          loadDeckFromText(text, hint);
        }catch(err){
          alert('Fetch failed: '+err+'\nIf loading a local file over file://, start a local server (e.g. `python -m http.server`) and try http://localhost/. Also ensure the remote server allows CORS.');
        }
      });
    }

    // First render
    rebuildOrder();
  </script>
</body>
</html>
